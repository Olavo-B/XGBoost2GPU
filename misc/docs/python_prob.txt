    def calculate_forest_probabilities(self, percentage_to_cut, output_file='cut_probabilities.csv', 
                                       strategy="linear", level_importance=0.5, progress_importance=0.3,
                                       level_bias=2.0, max_cut_percentage=0.3):
        """
        Calculate cut probabilities for all nodes in a forest by walking through them

        General mathematical formula:
        P(cut) = min(1.0, P_base × L_factor × U_factor)
        
        Where:
        - P_base = (total_to_cut - cut_so_far) / (total_nodes - cut_so_far)
        - L_factor = level function (strategy-dependent)
        - U_factor = urgency factor based on progress
        
        Args:
            percentage_to_cut: percentage of total nodes to cut
            output_file: path to the output CSV file
            strategy: calculation strategy ("linear", "exponential", "adaptive", "sigmoid")
            level_importance: controls level impact (0.0 to 1.0+)
            progress_importance: controls progress impact (0.0 to 1.0+)  
            level_bias: base multiplier to give more weight to level (1.0+)
            max_cut_percentage: maximum percentage of nodes to cut in each tree (default 0.3)

        Returns:
            list of probabilities corresponding to each node
        """
        total_nodes_in_forest = sum(self._model.nodes())
        nodes_cut_so_far = 0
        total_nodes_to_cut = int(total_nodes_in_forest * percentage_to_cut)
        probabilities = []
        
        # Initialize hash function for consistent decisions
        pruner = TreePruningHash()

        for tree in self._trees:
            num_nodes_tree = len(tree)
            nodes_cut_in_tree = 0
            for node_id , node in tree.items():

                # Calculate node level based on its id
                node['level'] = 0
                current_node = node_id
                while current_node != 0:
                    parent_node = tree[current_node]['parent_node']
                    node['level'] += 1
                    current_node = parent_node
                # # Ensure node has a 'level' key
                # if 'level' not in node:
                #     node['level'] = 0


                # Calculate probability for current node
                prob = self._calculate_cut_probability(
                    node_level          =node['level'],
                    nodes_cut_so_far    =nodes_cut_so_far,
                    total_nodes_to_cut  =total_nodes_to_cut,
                    nodes_cut_in_tree   =nodes_cut_in_tree,
                    num_nodes_tree      =num_nodes_tree,
                    max_cut_percentage  =max_cut_percentage,
                    strategy            =strategy,
                    level_importance    =level_importance,
                    progress_importance =progress_importance,
                    level_bias          =level_bias
                )

                probabilities.append(prob)
            
                # 2025-06-16 14:26:34
                # Simulate cutting decision with 100 random threads id
                temp_cut = 0
                for i in range(1000):
                    thread_id = random.randint(0, 1000)  # Simulate thread ID
                    if pruner.should_cut_node(thread_id, prob, node['global_id']):
                        temp_cut += 1

                nodes_cut_so_far  += 1 if temp_cut > 1000/2 else 0  # Simulate cutting decision based on probability
                nodes_cut_in_tree += 1 if temp_cut > 1000/2 else 0  # Simulate cutting decision based on probability

        # Save probabilities in a .csv file
        with open(output_file, 'w') as f:
            for node_id, prob in enumerate(probabilities):
                f.write(f"{prob}\n")

        self._prune = probabilities  # Store probabilities for later use
         
    def should_cut_node(self, thread_id: int, node_id: int) -> int:
        """Determine if a node should be cut based on its ID and a cut probability.
        Args:
            node_id (int): The unique identifier for the node.

        Returns:
            int: 0 if the node should be cut, 1 if it should not.
        """
        if self._prune is None:
            raise ValueError("Prune vector is not set.")
        cut_probability = self._prune[node_id] if node_id < len(self._prune) else 0.0
        pruner = TreePruningHash()
        return pruner.should_cut_node(thread_id, cut_probability, node_id)
        
def _calculate_cut_probability(self, node_level, nodes_cut_so_far, total_nodes_to_cut,
                                nodes_cut_in_tree, num_nodes_tree, max_cut_percentage,
                                strategy,
                                level_importance, progress_importance,
                                level_bias):
        """
        Calculate cut probability based on tree parameters
        
        General mathematical formula:
        P(cut) = min(1.0, P_base × L_factor × U_factor)
        
        Where:
        - P_base = (total_to_cut - cut_so_far) / (total_nodes - cut_so_far)
        - L_factor = level function (strategy-dependent)
        - U_factor = urgency factor based on progress

        Args:
            node_level: node level in tree (0 = root)
            nodes_cut_so_far: how many nodes have been cut already
            total_nodes_to_cut: target total nodes to cut
            node_cut_in_tree: how many nodes have been cut in the current tree
            max_cut_percentage: maximum percentage of nodes to cut in each tree (default 0.3)
            strategy: calculation strategy ("linear", "exponential", "adaptive", "sigmoid")
            level_importance: controls level impact (0.0 to 1.0+)
            progress_importance: controls progress impact (0.0 to 1.0+)  
            level_bias: base multiplier to give more weight to level (1.0+)

        Returns:
            probability between 0.0 and 1.0, beeing 0.0 the node will be cut and 1.0 the node will not be cut.
        """
        # Early termination cases
        if nodes_cut_so_far >= total_nodes_to_cut:
            return 0.0
        if nodes_cut_in_tree >= num_nodes_tree * max_cut_percentage and (total_nodes_to_cut - nodes_cut_so_far) > 2 * num_nodes_tree:
            # If too many nodes have been cut in this tree and there are still many to cut, skip further cuts
            return 0.0

        total_nodes_in_forest = sum(self._model.nodes())
        remaining_to_cut = total_nodes_to_cut - nodes_cut_so_far
        remaining_nodes = total_nodes_in_forest - nodes_cut_so_far

        if remaining_nodes <= 0:
            return 0.0

        # Base probability: P_base = remaining_to_cut / remaining_nodes
        base_probability = remaining_to_cut / remaining_nodes

        # Level factor with higher importance
        if strategy == "linear":
            # L_factor = level_bias + (level × level_importance)
            level_factor = level_bias + (node_level * level_importance)
            
        elif strategy == "exponential":
            # L_factor = level_bias × (1 + level_importance)^level
            level_factor = level_bias * ((1 + level_importance) ** node_level)
            
        elif strategy == "sigmoid":
            # L_factor = level_bias × sigmoid(level × level_importance)
            # Sigmoid smooths growth for very high levels
            sigmoid_input = node_level * level_importance
            sigmoid_value = 1 / (1 + math.exp(-sigmoid_input + 3))  # Shift to start low
            level_factor = level_bias * (1 + sigmoid_value)
            
        elif strategy == "adaptive":
            # Combine level factor with progress-based urgency
            level_factor = level_bias + (node_level * level_importance)
            
            # Urgency factor based on progress
            progress_ratio = nodes_cut_so_far / total_nodes_to_cut if total_nodes_to_cut > 0 else 0
            expected_progress = 0.5  # Target: 50% progress
            
            # U_factor based on expected progress deviation
            progress_deviation = progress_ratio - expected_progress
            if progress_deviation < 0:  # We're behind schedule
                urgency_factor = 1.0 + abs(progress_deviation) * progress_importance * 2
            else:  # We're ahead of schedule
                urgency_factor = 1.0 - progress_deviation * progress_importance
                
            urgency_factor = max(0.1, urgency_factor)  # Never lower than 0.1
            level_factor *= urgency_factor
            
        elif strategy == "random":
            # Random factor between 0.0 and 1.0
            import random
            level_factor = random.uniform(0.0, 1.0)

        # Final probability: P(cut) = min(1.0, P_base × L_factor)
        final_probability = min(1.0, base_probability * level_factor)
        
        return final_probability
